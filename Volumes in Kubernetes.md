1.  **Volumes in Kubernetes**

The Pods generated in Kubernetes are transient in nature, suppose when a pod is
created to process data and then deleted, the data which is processed by the pod
also gets deleted. Kubernetes doesn’t give us data persistence by default, we
need to configure manually to save the data which is generated by the pod. For
this we attach a volume to the pod. The data generated by the pod is stored in
the volume and even after the pod is deleted the data is still stored in the
volumes.so the new pod can start where the old pod left of, it will read the
existed data in storage and start from there.

-   **Sample implementation of Volumes of Kubernetes**:

apiVersion: v1

kind: Pod

metadata:

name: random-number-generator

spec:

containers:

- image: alpine

name: alpine

command: [“/bin/sh”,”-c”]

args: [“shuf -i 0-100 -n 1 \>\> /opt/number.out;”]

volumeMounts:

- mountpath: /opt

name: data volume

volumes:

- name: data-volume

hostpath:

path: /data

type: Directory

The above yaml file generates a random number between 0 to 100. when the number
is generated it will be stored in /opt mount inside the container which happens
to be in the data-volume on the container which is in fact the data directory on
the host.

Note: Kubernetes support several type of different storage solutions such as
NFS, amazon block storage, google cloud storage, GlusterFS.

-   **Example for configuring AWS Elastic Block storage volume as the storage
    option for the volume** :

![](media/31a7daefd64d397c8209449708774b03.emf)

1.  **Persistent Volumes**:

When we have a large environment with a lot of users deploying a lot of pods
then the users would have to configure storage whenever a new pod is created.
whatever storage definition is used the users who deploys the pods would have to
configure that on all other pod files in that environment so whenever a change
is made the user should change them in all other pods. For this if we managed
storage centrally like we would configure in a way that administrator can create
a large pool of storage and then users carve out pieces from it as required that
is where persistent volumes can help us. A persistent volume is a cluster wide
pool of storage volumes configured by the administrator to be used by the users
for deploying applications on the cluster. The users can now select storage as
per there need from the pool using persistent volume claim.

-   **Sample for Persistent Volume on Kubernetes:**

apiVersion: v1

kind: PersistentVolume

metadata:

name: example-persistent-volume

spec:

accessModes:

-ReadWriteOnce

capacity:

storage: 1Gi

awsElasticBlockStore:

volumeID: \<volume-id\>

fsType: ext4

1.  **Persistent Volume Claims**:

Persistent volume and Persistent volume claim are two different objects in
Kubernetes namespace. The administrator creates persistent volumes and the users
create persistent volume claim to use the storage. Once the persistent volume
claims are created Kubernetes binds the persistent volumes to claims based on
the request and properties set on the volume. Every Persistent volume claim is
bound to single persistent volume so during the binding process Kubernetes finds
the persistent volume that has sufficient capacity as requested by the claim and
any other request properties like access mode, volume modes, Storage class.
However if there are multiple matches for the claim and if we want to
specifically use a particular volume then we can use labels and selectors to
bind to the right volume. Finally note that a smaller claim may bind to larger
volume if all the other criteria matches and there are no better options. There
is a one to one relationship between claims and volumes so no other claim can
utilize the remaining capacity in the volume. If there are no volumes available
the persistent volume claim will be in pending state until new volumes are
created to the cluster. so when the new volumes are created, claim will
automatically bind to the new volume which is created.

-   **Sample for persistent volume claim on Kubernetes**:

apiVersion: v1

kind: PersistentVolumeClaim

metadata:

name: example-claim

spec:

accessModes:

- ReadWriteOnce

resources:

requests:

storage: 500Mi
